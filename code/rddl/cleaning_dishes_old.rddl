domain cleaning_dishes_old {

	types {
		location : object;
		item : object;
		agent : object;

		interm_level : { @level0, @level1 };
	};

    pvariables {

		// State fluents
		current-level                      	: { state-fluent, interm_level, default = @level0 };
		manipulation						: {	state-fluent, bool, default = false}; // probability of success of manipulation task

		obj-break(item)						: { state-fluent, bool, default = false }; // item status
		obj-loc(item, location)     		: { state-fluent, bool, default = false }; // item at location

		agent-loc(agent, location)			: { state-fluent, bool, default = false }; // agent at location
		inhand(agent, item)					: { state-fluent, bool, default = false }; // item inhand

		cleaned(location)     				: { state-fluent, bool, default = true }; // location cleaned or not
		
		// Action fluents
		pick(agent, item, location) 		: { action-fluent, bool, default = false }; // pick up item from a location
		place(agent, item, location) 		: { action-fluent, bool, default = false }; // place item at a location
		move(agent, location, location)		: { action-fluent, bool, default = false }; // move agent location l1 to l2
		
		clean(agent, location) 				: { action-fluent, bool, default = false }; // clean location

		COOKTOP(location)					: { non-fluent, bool, default = false };
		FRAGILE(item)						: { non-fluent, book, default = false }; // Fragile Items
		EQUAL(item, item)					: { non-fluent, book, default = false }; // Equivalent Items
		DESTINATION(item, location) 		: { non-fluent, bool, default = false }; // Additional nonfluent to specify a goal
		COST(agent, location, location)		: { non-fluent, int, default = 0 }; // Move costs
		MOP_ITEM(item)						: { non-fluent, bool, default = false };
		//CLEANING_ITEM(item)                 : { non-fluent, bool, default = false };
	};

	cpfs {

		current-level' =
            if (current-level == @level0) 
				then @level1
            else 
				@level0;

		manipulation' = 
			if (current-level == @level1)
				then Bernoulli(0.3)
			else
				manipulation;

		obj-break'(?i) = 
			if 	(exists_{?a : agent, ?l : location} (pick(?a, ?i, ?l) ^ ~manipulation ^ FRAGILE(?i) ))
				then true
			else if(exists_{?a : agent, ?l : location} (place(?a, ?i, ?l) ^ ~manipulation ^ FRAGILE(?i) ))
				then true
			else
				false;

		obj-loc'(?i, ?l) = 
			if (exists_{?a : agent} (obj-loc(?i, ?l) ^ pick(?a, ?i, ?l) ^ ((manipulation ^ FRAGILE(?i)) | ~FRAGILE(?i)) ))
				then false
			else if (exists_{?a : agent} (place(?a, ?i, ?l) ^ inhand(?a, ?i)))
				then true
			else
				obj-loc(?i, ?l);

		inhand'(?a, ?i) =
			if ( exists_{?l : location}( pick(?a, ?i, ?l) ^ ((manipulation ^ FRAGILE(?i)) | ~FRAGILE(?i)) ))
				then true
			else if(exists_{?l : location}(place(?a, ?i, ?l) ^ inhand(?a, ?i)))
				then false
			else
				inhand(?a, ?i);

		cleaned'(?l) = 
            if (exists_{?i : item} (obj-break(?i) ^ obj-loc(?i, ?l) ^ ~exists_{?m: item} (MOP_ITEM(?m) ^ obj-loc(?m, ?l))))
                then false  //Location remains dirty if no mop is there

            else if (exists_{?a : agent, ?i : item} (clean(?a, ?l) ^ obj-loc(?i, ?l) ^ MOP_ITEM(?i)))
                then true  // Location gets cleaned when using a mop

            else
                cleaned(?l);


		agent-loc'(?a, ?l) = 		
			// Did it move to ?l and become true?
			if (exists_{?from : location} (move(?a, ?from, ?l) ^ agent-loc(?a, ?from)))
				then true
			
			// Did it leave ?l and become false?
			else if (exists_{?to : location} (move(?a, ?l, ?to) ^ agent-loc(?a, ?l)))
				then false
				
			// It didn't move, so it's current value persists (frame axiom)
			else 
				agent-loc(?a, ?l);

	};

reward = 

    // Reward for placing objects correctly
    + 20 * [sum_{?i: item} exists_{?l : location} (obj-loc'(?i, ?l) ^ DESTINATION(?i, ?l) ^ ~obj-break(?i) ^ cleaned'(?l)) ]

    // Penalty for uncleaned locations
    - 30 * [sum_{?l : location} (~cleaned'(?l)) ]           

    // Movement cost
    - [sum_{?a: agent, ?wf: location, ?wt: location} [COST(?a, ?wf, ?wt) * move(?a, ?wf, ?wt)] ]

    // Penalty for picking or placing objects (encouraging minimal actions)
    - 10 * [sum_{?a: agent, ?i : item, ?l : location} [pick(?a, ?i, ?l) | place(?a, ?i, ?l)] ]

    // Reduced penalty for picking a fragile item and failing (encourages learning recovery)
    - 20 * [sum_{?a: agent, ?i: item, ?l: location} (pick(?a, ?i, ?l) ^ clean(?a, ?l) ^ ~manipulation ^ FRAGILE(?i))]

    // Moderate penalty for breaking a fragile item (allows breaking but discourages carelessness)
    - 20 * [sum_{?i: item} (obj-break'(?i) ^ FRAGILE(?i))]

    // Increased reward for picking up the mop as part of recovery
    + 30 * [sum_{?a: agent, ?m: item, ?l: location} (pick(?a, ?m, ?l) ^ MOP_ITEM(?m) ^ clean(?a, ?l))]

    // Stronger reward for cleaning up a broken object using a mop (encourages recovery)
    + 50 * [sum_{?a: agent, ?i: item, ?l: location} (clean(?a, ?l) ^ obj-break(?i) ^ obj-loc(?i, ?l) ^ MOP_ITEM(?i)) ];




	action-preconditions {
		forall_{?a: agent, ?i : item, ?l : location} [pick(?a, ?i, ?l) => agent-loc(?a, ?l) ^ obj-loc(?i, ?l) ^ ~obj-break(?i) ^ (current-level == @level0)];
		forall_{?a: agent, ?i : item, ?l : location} [place(?a, ?i, ?l) => agent-loc(?a, ?l) ^ ~obj-loc(?i, ?l) ^ inhand(?a, ?i) ^ (current-level == @level0)];

		forall_{?a: agent, ?l1 : location, ?l2 : location} [move(?a, ?l1, ?l2) => ~agent-loc(?a, ?l2) ^ agent-loc(?a, ?l1) ^ (current-level == @level0)];

		forall_{?a: agent, ?l : location} [clean(?a, ?l) => agent-loc(?a, ?l) ^ exists_{?m: item} (inhand(?a, ?m) ^ MOP_ITEM(?m)) ^ (current-level == @level0)];



	};
}
domain household_v1 {

	types {
		location : object;
		item : object;
		agent : object;

		food : item;
		toBake : item;

		interm_level : { @level0, @level1 };
	};

    pvariables {

		// State fluents
		current-level                      	: { state-fluent, interm_level, default = @level0 };
		manipulation						: {	state-fluent, bool, default = false}; // probability of success of manipulation task

		obj-break(item)						: { state-fluent, bool, default = false }; // item status
		obj-loc(item, location)     		: { state-fluent, bool, default = false }; // item at location

		agent-loc(agent, location)			: { state-fluent, bool, default = false }; // agent at location
		inhand(agent, item)					: { state-fluent, bool, default = false }; // item inhand
		hand_full(agent)					: { state-fluent, bool, default = false }; // item inhand

		cleaned(location)     				: { state-fluent, bool, default = true }; // location cleaned or not

		bake(toBake)						: { state-fluent, bool, default = false }; // item baked or not
		
		// Action fluents
		pick(agent, item, location) 		: { action-fluent, bool, default = false }; // pick up item from a location
		place(agent, item, location) 		: { action-fluent, bool, default = false }; // place item at a location
		move(agent, location, location)		: { action-fluent, bool, default = false }; // move agent location l1 to l2
		
		clean(agent, location) 				: { action-fluent, bool, default = false }; // clean location

		Tobake(agent, toBake)				: { action-fluent, bool, default = false }; // bake food

		COOKTOP(location)					: { non-fluent, bool, default = false };
		FRAGILE(item)						: { non-fluent, book, default = false }; // Fragile Items
		EQUAL(item, item)					: { non-fluent, book, default = false }; // Equivalent Items
		DESTINATION(item, location) 		: { non-fluent, bool, default = false }; // Additional nonfluent to specify a goal
		COST(agent, location, location)		: { non-fluent, int, default = 0 }; // Move costs
		MOP_ITEM(item)						: { non-fluent, bool, default = false };
	};

	cpfs {

		current-level' =
            if (current-level == @level0) 
				then @level1
            else 
				@level0;

		manipulation' = 
			if (current-level == @level1)
				then Bernoulli(0.3)
			else
				manipulation;

		obj-break'(?i) = 
			if 	(exists_{?a : agent, ?l : location} (pick(?a, ?i, ?l) ^ ~manipulation ^ FRAGILE(?i) ))
				then true
			else if(exists_{?a : agent, ?l : location} (place(?a, ?i, ?l) ^ ~manipulation ^ FRAGILE(?i) ))
				then true
			else
				false;

		obj-loc'(?i, ?l) = 
			if (exists_{?a : agent} (obj-loc(?i, ?l) ^ pick(?a, ?i, ?l) ^ ((manipulation ^ FRAGILE(?i)) | ~FRAGILE(?i)) ))
				then false
			else if (exists_{?a : agent} (place(?a, ?i, ?l) ^ inhand(?a, ?i)))
				then true
			else
				obj-loc(?i, ?l);

		inhand'(?a, ?i) =
			if ( exists_{?l : location}( pick(?a, ?i, ?l) ^ ((manipulation ^ FRAGILE(?i)) | ~FRAGILE(?i)) ))
				then true
			else if(exists_{?l : location}(place(?a, ?i, ?l) ^ inhand(?a, ?i)))
				then false
			else
				inhand(?a, ?i);

		cleaned'(?l) = 
			if 	(exists_{?i : item} (obj-break(?i) ^ obj-loc(?i, ?l))) // Object broke
				then false
			else if(exists_{?a : agent, ?i : item} ( clean(?a, ?l) ^ obj-loc(?i, ?l) ^ MOP_ITEM(?i) ))
				then true
			else
				cleaned(?l);

		agent-loc'(?a, ?l) = 		
			// Did it move to ?l and become true?
			if (exists_{?from : location} (move(?a, ?from, ?l) ^ agent-loc(?a, ?from)))
				then true
			
			// Did it leave ?l and become false?
			else if (exists_{?to : location} (move(?a, ?l, ?to) ^ agent-loc(?a, ?l)))
				then false
				
			// It didn't move, so it's current value persists (frame axiom)
			else 
				agent-loc(?a, ?l);

		bake'(?i) = 
			if (exists_{?a : agent, ?l: location} (obj-loc(?i, ?l) ^ Tobake(?a, ?i) ^ COOKTOP(?l) ))
				then true
			else
				bake(?i);

		hand_full'(?a) = 
		if (exists_{?i : item} (inhand(?a, ?i)) )
			then true
		else
			false;
	};

	reward = 20 * [sum_{?i: item} exists_{?l : location} (obj-loc'(?i, ?l) ^ DESTINATION(?i, ?l) ^ ~obj-break(?i) ^ cleaned(?l)) ]
			//+ 10 * [sum_{?l : location}(cleaned(?l))]
			- 10 * [sum_{?l : location}(~cleaned(?l))]
			- [sum_{?a: agent, ?wf: location, ?wt: location} [COST(?a, ?wf, ?wt) * move(?a, ?wf, ?wt)]]
			- [sum_{?a: agent, ?i : item, ?l : location} [10 * [pick(?a, ?i, ?l) | place(?a, ?i, ?l)] ]];
			//+ 20 * [sum_{?i: toBake} (bake(?i) )]


	action-preconditions {
		forall_{?a: agent, ?i : item, ?l : location} [pick(?a, ?i, ?l) => agent-loc(?a, ?l) ^ obj-loc(?i, ?l) ^ ~obj-break(?i) ^ (current-level == @level0)];
		forall_{?a: agent, ?i : item, ?l : location} [place(?a, ?i, ?l) => agent-loc(?a, ?l) ^ ~obj-loc(?i, ?l) ^ inhand(?a, ?i) ^ (current-level == @level0)];

		forall_{?a: agent, ?l1 : location, ?l2 : location} [move(?a, ?l1, ?l2) => ~agent-loc(?a, ?l2) ^ agent-loc(?a, ?l1) ^ (current-level == @level0)];

		forall_{?a: agent, ?l : location} [clean(?a, ?l) => agent-loc(?a, ?l) ^ (current-level == @level0)];

		forall_{?a: agent, ?i : toBake} [Tobake(?a, ?i) => [exists_{?l: location} (agent-loc(?a, ?l) ^ COOKTOP(?l))] ^ ~bake(?i) ^ (current-level == @level0)];

	};
}

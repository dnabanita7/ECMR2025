domain domain_x_robot_anticipation {

    types {
        location : object;
        item : object;
        agent : object;
        human: object;
        interm_level : { @level0, @level1 };
        //container :  item;
    };

    pvariables {
        // State fluents
        current-level                      	: { state-fluent, interm_level, default = @level0 };
		manipulation						: {	state-fluent, bool, default = false}; // probability of success of manipulation task


        agent-loc(agent, location)			: { state-fluent, bool, default = false }; // agent at location
        human-loc(human, location)			: { state-fluent, bool, default = false }; // agent at location
        
        obj-loc(item, location)  : { state-fluent, bool, default = false };
        inhand(agent, item)      : { state-fluent, bool, default = false };
        inhand-human(human, item)      : { state-fluent, bool, default = false };
        obj-break(item)          : { state-fluent, bool, default = false };
        cleaned(location)        : { state-fluent, bool, default = true };
        food-in(item, item)					: { state-fluent, bool, default = false }; // item in receptacle or appliance
		
        switch_appliance(location)			: { state-fluent, bool, default = false };
        open(location)                      : { state-fluent, bool, default = false };

        // Action fluents
        move(agent, location, location) : { action-fluent, bool, default = false };
        move_human(human, location, location) : { action-fluent, bool, default = false };
        pick(agent, item, location)     : { action-fluent, bool, default = false };
        pick_human(human, item, location)     : { action-fluent, bool, default = false };
        place(agent, item, location)    : { action-fluent, bool, default = false };
        place_human(human, item, location)    : { action-fluent, bool, default = false };
        clean(agent, location)          : { action-fluent, bool, default = false };
        clean_human(human, location)          : { action-fluent, bool, default = false };
        put_in(agent, item, item)			: { action-fluent, bool, default = false }; // put object in receptacle
        put_in_human(human, item, item)			: { action-fluent, bool, default = false }; // put object in receptacle

        agent_switch_on(agent, location)			: { action-fluent, bool, default = false };
	    agent_switch_off(agent, location)		: { action-fluent, bool, default = false };
        human_switch_on(human, location)			: { action-fluent, bool, default = false };
	    human_switch_off(human, location)		: { action-fluent, bool, default = false };

        agent_open(agent, location)			: { action-fluent, bool, default = false };
	    agent_close(agent, location)		: { action-fluent, bool, default = false };
        human_open(human, location)			: { action-fluent, bool, default = false };
	    human_close(human, location)		: { action-fluent, bool, default = false };

        // Non-fluent variables
        COST(agent, location, location) : { non-fluent, int, default = 0 };
        //COST_HUMAN(human, location, location) : { non-fluent, int, default = 0 };
        FRAGILE(item)                   : { non-fluent, bool, default = false };
        MOP_ITEM(item)                  : { non-fluent, bool, default = false };
        FOOD_ITEM(item)                 : { non-fluent, bool, default = false };
        EQUAL(item, item)               : { non-fluent, bool, default = false };
        GOAL_0(item, item, location)      : { non-fluent, bool, default = false };
        GOAL_1(item, item, location)      : { non-fluent, bool, default = false };
        GOAL_2(item, item, location)      : { non-fluent, bool, default = false };
        DESTINATION_0(item, location)     : { non-fluent, bool, default = false };
        DESTINATION_1(item, location)   : { non-fluent, bool, default = false };
        DESTINATION_2(item, location)   : { non-fluent, bool, default = false };
        //DESTINATION_3(item, location)   : { non-fluent, bool, default = false };
        CONTAINER(item)                 : { non-fluent, bool, default = false };
        //GOAL_LOCATION(location)         : {  non-fluent, bool, default = false };

        APPLIANCE(location)                 : { non-fluent, bool, default = false };

    };

    cpfs {

            current-level' =
                if (current-level == @level0) 
                    then @level1
                else 
                    @level0;

            manipulation' = 
                if (current-level == @level1)
                    then Bernoulli(0.3)
                else
                    manipulation;



            human-loc'(?h, ?l) =
            // If the human decides to move FROM a location
            if (exists_{?from : location} (move_human(?h, ?from, ?l) ^ human-loc(?h, ?from))) 
                then Bernoulli(0.8)  // 80% chance they reach `?l`
            
            // Did it leave ?l and become false?
            else if (exists_{?to : location} (move_human(?h, ?l, ?to) ^ human-loc(?h, ?l)))
                then false
                
            // If no movement happens, the human stays in their current location
            else 
                human-loc(?h, ?l);
        
    
    
            inhand'(?a, ?i) =
                if ( exists_{?l : location}( pick(?a, ?i, ?l) ^ agent-loc(?a, ?l) ))
                    then true
                else if(exists_{?l : location}(place(?a, ?i, ?l) ))
                    then false
                else if(exists_{?l : location, ?f : item}(put_in(?a, ?f, ?i) ^ FOOD_ITEM(?f) ^ CONTAINER(?i) ))
                    then false
                else if(exists_{?h:human} (inhand-human(?h, ?i)))
                    then false
                else
                    inhand(?a, ?i);
    
            inhand-human'(?h, ?i) =
                if (exists_{?l : location}( pick_human(?h, ?i, ?l) ^ human-loc(?h, ?l) ^ FRAGILE(?i)))
                    then Bernoulli(0.1)
                else if (exists_{?l : location}( pick_human(?h, ?i, ?l) ^ ~FRAGILE(?i)))
                    then Bernoulli(0.9)
                else if(exists_{?l : location}(place_human(?h, ?i, ?l) ))
                    then false
                else if(exists_{?l : location, ?f : item}(put_in_human(?h, ?f, ?i) ^ FOOD_ITEM(?f) ^ CONTAINER(?i)))
                    then false
                else if(exists_{?a:agent} (inhand(?a, ?i)))
                    then false
                else
                    inhand-human(?h, ?i);
    
            obj-break'(?i) = 
                if(exists_{?h : human, ?l : location} ((pick_human(?h, ?i, ?l) ) ^ FRAGILE(?i)))
                    then Bernoulli(0.9)
                else if(exists_{?h : human, ?l : location, ?f : item} ((place_human(?h, ?i, ?l) | inhand-human(?h, ?i)) | (FOOD_ITEM(?f) ^ CONTAINER(?i) ^ put_in_human(?h, ?f, ?i) | inhand-human(?h, ?i)) ^ FRAGILE(?i) ))
                    then Bernoulli(0.9)
                else if(exists_{?a: agent, ?l : location} (pick(?a, ?i, ?l)))
                    then false
                else if(exists_{?a : agent, ?l : location} (place(?a, ?i, ?l) | inhand(?a, ?i)))
                    then false
                else if(exists_{?a : agent, ?l : location, ?f :  item} (put_in(?a, ?f, ?i) ^ FOOD_ITEM(?f) ^ CONTAINER(?i) | inhand(?a, ?i)))
                    then false
                else if (exists_{?h: human, ?l : location} (pick_human(?h, ?i, ?l) ^ ~FRAGILE(?i)))
                    then Bernoulli(0.1)
                else if(exists_{?h : human, ?l : location, ?f: item} ((place_human(?h, ?i, ?l) | inhand-human(?h, ?i)) | (FOOD_ITEM(?f) ^ CONTAINER(?i) ^ put_in_human(?h, ?f, ?i) | inhand-human(?h, ?i))  ^ ~FRAGILE(?i) ))
                    then Bernoulli(0.1)
                else
                    false;
    
            food-in'(?f, ?i) = 
                if (exists_{?a : agent} (FOOD_ITEM(?f) ^ CONTAINER(?i) ^ put_in(?a, ?f, ?i) ^ inhand(?a, ?f) ))
                    then true
                else if (exists_{?h : human} (FOOD_ITEM(?f) ^ CONTAINER(?i) ^ put_in_human(?h, ?f, ?i) ^ inhand-human(?h, ?f) ))
                    then true
                else
                    food-in(?f, ?i);
    
            obj-loc'(?i, ?l) = 
                if (exists_{?a : agent} (pick(?a, ?i, ?l)))
                    then false  // Robot picked up the item, remove from location
                else if (exists_{?h : human} (pick_human(?h, ?i, ?l) ))
                    then false  // Human picked up the item, remove from location
                else if (exists_{?a : agent} (place(?a, ?i, ?l)))
                    then true  // The item in the robot's hand is in obj-loc
                else if (exists_{?a : agent, ?f: item} (put_in(?a, ?f, ?i) ^ FOOD_ITEM(?f) ^ CONTAINER(?i)))
                    then true  
                else if (exists_{?a: agent} (inhand(?a, ?i)))
                    then false
                else if (exists_{?h : human} (place_human(?h, ?i, ?l)))
                    then true  // The item is now in the human's hand
                else if (exists_{?h : human, ?f: item} (put_in_human(?h, ?f, ?i) ^ FOOD_ITEM(?f) ^ CONTAINER(?i)))
                    then true  
                else if (exists_{?h : human} (inhand-human(?h, ?i)))
                    then false
                else obj-loc(?i, ?l);  // Otherwise, the item stays in the same location
                
    
    
            
    
            agent-loc'(?a, ?l) = 		
                // Did it move to ?l and become true?
                if (exists_{?from : location} (move(?a, ?from, ?l) ^ agent-loc(?a, ?from)))
                    then true
                
                // Did it leave ?l and become false?
                else if (exists_{?to : location} (move(?a, ?l, ?to) ^ agent-loc(?a, ?l)))
                    then false
                    
                // It didn't move, so it's current value persists (frame axiom)
                else 
                    agent-loc(?a, ?l);
    
            cleaned'(?l) = 
                if (exists_{?i : item, ?a: agent} (obj-break(?i) ^ obj-loc(?i, ?l) ^ agent-loc(?a, ?l) ^ ~exists_{?m: item} (MOP_ITEM(?m) ^ obj-loc(?m, ?l) ^ agent-loc(?a, ?l))))
                    then false  //Location remains dirty if no mop is there
    
                else if (exists_{?i : item, ?h: human} (obj-break(?i) ^ obj-loc(?i, ?l) ^ human-loc(?h, ?l) ^ ~exists_{?m: item} (MOP_ITEM(?m) ^ obj-loc(?m, ?l) ^ human-loc(?h, ?l))))
                    then false  //Location remains dirty if no mop is there
    
                else if (exists_{?a : agent, ?i : item} (clean(?a, ?l) ^ agent-loc(?a, ?l) ^ obj-loc(?i, ?l) ^ MOP_ITEM(?i)))
                    then true  // Location gets cleaned when using a mop
    
                else if (exists_{?h : human, ?i : item} (clean_human(?h, ?l) ^ human-loc(?h, ?l) ^ obj-loc(?i, ?l) ^ MOP_ITEM(?i)))
                    then true  // Location gets cleaned when using a mop
    
                else
                    cleaned(?l);

        switch_appliance'(?l) = 
			if (exists_{?a : agent} (agent_switch_on(?a, ?l) ^ APPLIANCE(?l)))
				then true
			else if (exists_{?a : agent} (agent_switch_off(?a, ?l) ^ APPLIANCE(?l) ))
				then false
			else if (exists_{?h : human} (human_switch_on(?h, ?l) ^ APPLIANCE(?l) ))
				then Bernoulli(0.9)
			else if (exists_{?h : human} (human_switch_off(?h, ?l) ^ APPLIANCE(?l) ))
				then Bernoulli(0.1)
			else
				switch_appliance(?l);
		
        open'(?obj) = 
			if (exists_{?a : agent} (agent_open(?a, ?obj) ))
				then true
			else if (exists_{?a : agent} (agent_close(?a, ?obj) ))
				then false
			else if (exists_{?h : human} (human_open(?h, ?obj) ))
				then Bernoulli(0.8)
			else if (exists_{?h : human} (human_close(?h, ?obj) ))
				then Bernoulli(0.2)
			else
				open(?obj);
        
    };



// best one till now!!
//reward =
        // Reward for placing items correctly at their destination
        //+ 80 * [sum_{?f: item} exists_{?l: location} (FOOD_ITEM(?f) ^ obj-loc'(?f, ?l) ^ (DESTINATION_0(?f, ?l) | DESTINATION_1(?f, ?l) | DESTINATION_2(?f, ?l) ))]
        //+ 200 * [sum_{?f: item, ?i: item, ?l: location} (FOOD_ITEM(?f) ^ CONTAINER(?i) ^ food-in'(?f, ?i) ^ (GOAL_0(?f, ?i, ?l) | GOAL_1(?f, ?i, ?l) | GOAL_2(?f, ?i, ?l)))]

        // Reward for successfully picking and placing items
        //+ 40 * [sum_{?a: agent, ?i: item, ?l: location} ((pick(?a, ?i, ?l) | place(?a, ?i, ?l)) ^ obj-loc'(?i, ?l))]
        //+ 40 * [sum_{?i: item, ?l: location} exists_{?h: human} ((pick_human(?h, ?i, ?l) | place_human(?h, ?i, ?l)) ^ obj-loc'(?i, ?l))]
        //+ 60 * [sum_{?a: agent, ?f: item, ?i: item} (FOOD_ITEM(?f) ^ CONTAINER(?i) ^ put_in(?a, ?f, ?i) ^ food-in'(?f, ?i))]
       // + 60 * [sum_{?f: item, ?i: item} exists_{?h: human} (FOOD_ITEM(?f) ^ CONTAINER(?i) ^ put_in_human(?h, ?f, ?i) ^ food-in'(?f, ?i))]

                
        // Penalty for not cleaning up broken objects
       // - 10 * [sum_{?l: location} (~cleaned(?l))]
        
        // Reward robot for picking up the mop OR moving toward fragile items if human is holding one
        //+ 20 * [sum_{?a: agent, ?m: item, ?l: location} 
        //        ((pick(?a, ?m, ?l) ^ MOP_ITEM(?m)) | move(?a, ?l, ?l)) &
         //       obj-loc'(?m, ?l) & exists_{?h: human, ?i: item} (inhand-human'(?h, ?i)) & FRAGILE(?i)]
        
        // Reward for assisting humans (picking or placing together)
       // + 10 * [sum_{?a: agent, ?i: item, ?l: location} exists_{?h: human} 
        //        ((pick(?a, ?i, ?l) | pick_human(?h, ?i, ?l)) |
        //         (place(?a, ?i, ?l) | place_human(?h, ?i, ?l)))]
        
        // Small penalty for excessive movement (to avoid pointless wandering)
        //- 7 * [sum_{?a: agent, ?l1: location, ?l2: location} 
        //        (move(?a, ?l1, ?l2) & (COST(?a, ?l1, ?l2) > 10))];



// experimentation

reward = if (forall_{?app: location} ~switch_appliance(?app)) 
         then 500 else -5;






    state-action-constraints {

// misc preconditions/constraints


        forall_{?a: agent, ?i : item, ?l : location, ?h: human} [pick(?a, ?i, ?l) => agent-loc(?a, ?l) ^ obj-loc(?i, ?l) ^ ~obj-break(?i) ^ ~inhand-human(?h, ?i)];

        forall_{?a: agent, ?l1 : location, ?l2 : location} [move(?a, ?l1, ?l2) => ~agent-loc(?a, ?l2) ^ agent-loc(?a, ?l1)];

		forall_{?a: agent, ?i : item, ?l : location} [place(?a, ?i, ?l) => agent-loc(?a, ?l) ^ ~obj-loc(?i, ?l) ^ inhand(?a, ?i) ^ pick(?a, ?i, ?l)];

        forall_{?a: agent, ?f: item, ?i: item} [put_in(?a, ?f, ?i) => ~food-in(?f, ?i) ^ FOOD_ITEM(?f) ^ CONTAINER(?i) ^ [exists_{?l: location}(obj-loc(?i, ?l) ^ agent-loc(?a, ?l))] ^inhand(?a, ?f) ];

        forall_{?a: agent, ?l : location} [clean(?a, ?l) => agent-loc(?a, ?l) ^ exists_{?m: item} (inhand(?a, ?m) ^ MOP_ITEM(?m)) ];


        forall_{?a: agent, ?h: human, ?i : item, ?l : location} [pick_human(?h, ?i, ?l) => human-loc(?h, ?l) ^ obj-loc(?i, ?l) ^ ~obj-break(?i) ^ ~inhand(?a, ?i)];

        forall_{?h: human, ?l1 : location, ?l2 : location} [move_human(?h, ?l1, ?l2) => ~human-loc(?h, ?l2) ^ human-loc(?h, ?l1)];

        forall_{?h: human, ?i : item, ?l : location} [place_human(?h, ?i, ?l) => human-loc(?h, ?l) ^ ~obj-loc(?i, ?l) ^ inhand-human(?h, ?i)];

        forall_{?a: human, ?f: item, ?i: item} [put_in_human(?a, ?f, ?i) => ~food-in(?f, ?i) ^ FOOD_ITEM(?f) ^ CONTAINER(?i) ^ [exists_{?l: location}(obj-loc(?i, ?l) ^ human-loc(?a, ?l))] ^inhand-human(?a, ?f) ];



// preconditions for switching                                            
	
	forall_{?a: agent, ?app: location} [agent_switch_on(?a, ?app) => APPLIANCE(?app) ^ ~switch_appliance(?app) ^ agent-loc(?a, ?app)];

	forall_{?a: agent, ?app: location} [agent_switch_off(?a, ?app) => APPLIANCE(?app) ^ switch_appliance(?app) ^ agent-loc(?a, ?app)] ;

	forall_{?h: human, ?app: location} [human_switch_on(?h, ?app) => APPLIANCE(?app) ^ ~switch_appliance(?app) ^ human-loc(?h, ?app)]  ;

	forall_{?h: human, ?app: location} [human_switch_off(?h, ?app) => APPLIANCE(?app) ^ switch_appliance(?app) ^  human-loc(?h, ?app)]  ;

	forall_{?a: agent, ?app: location} [agent_open(?a, ?app) => APPLIANCE(?app) ^ ~open(?app) ^ agent-loc(?a, ?app)]; //What to open?

	forall_{?a: agent, ?app: location} [agent_close(?a, ?app) => APPLIANCE(?app) ^ open(?app) ^ agent-loc(?a, ?app)] ;

	forall_{?h: human, ?app: location} [human_open(?h, ?app) => APPLIANCE(?app) ^ ~open(?app) ^ human-loc(?h, ?app)];

	forall_{?h: human, ?app: location} [human_close(?h, ?app) => APPLIANCE(?app) ^ open(?app) ^ human-loc(?h, ?app)];

    };
}